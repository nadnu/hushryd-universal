import { DatabaseType, getDatabaseConfig } from './config';
import { DatabaseConnection, dbManager } from './connection';
import { getDatabaseSchema } from './models';

export interface Migration {
  version: string;
  name: string;
  up: (connection: DatabaseConnection) => Promise<void>;
  down: (connection: DatabaseConnection) => Promise<void>;
}

export class MigrationManager {
  private connection: DatabaseConnection;
  private dbType: DatabaseType;

  constructor(connection: DatabaseConnection, dbType: DatabaseType) {
    this.connection = connection;
    this.dbType = dbType;
  }

  async initialize(): Promise<void> {
    await this.createMigrationsTable();
  }

  private async createMigrationsTable(): Promise<void> {
    const schemas = {
      mysql: `
        CREATE TABLE IF NOT EXISTS migrations (
          id INT AUTO_INCREMENT PRIMARY KEY,
          version VARCHAR(50) UNIQUE NOT NULL,
          name VARCHAR(255) NOT NULL,
          executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
      `,
      postgresql: `
        CREATE TABLE IF NOT EXISTS migrations (
          id SERIAL PRIMARY KEY,
          version VARCHAR(50) UNIQUE NOT NULL,
          name VARCHAR(255) NOT NULL,
          executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
      `,
      oracle: `
        CREATE TABLE migrations (
          id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          version VARCHAR2(50) UNIQUE NOT NULL,
          name VARCHAR2(255) NOT NULL,
          executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
      `,
    };

    await this.connection.query(schemas[this.dbType]);
  }

  async getExecutedMigrations(): Promise<string[]> {
    const result = await this.connection.query('SELECT version FROM migrations ORDER BY executed_at');
    return result.rows.map((row: any) => row.version);
  }

  async executeMigration(migration: Migration): Promise<void> {
    const executedMigrations = await this.getExecutedMigrations();
    
    if (executedMigrations.includes(migration.version)) {
      console.log(`Migration ${migration.version} already executed, skipping...`);
      return;
    }

    console.log(`Executing migration ${migration.version}: ${migration.name}`);
    
    await this.connection.transaction(async (trx) => {
      await migration.up(trx);
      await trx.query(
        'INSERT INTO migrations (version, name) VALUES (?, ?)',
        [migration.version, migration.name]
      );
    });

    console.log(`Migration ${migration.version} executed successfully`);
  }

  async rollbackMigration(migration: Migration): Promise<void> {
    const executedMigrations = await this.getExecutedMigrations();
    
    if (!executedMigrations.includes(migration.version)) {
      console.log(`Migration ${migration.version} not found, skipping rollback...`);
      return;
    }

    console.log(`Rolling back migration ${migration.version}: ${migration.name}`);
    
    await this.connection.transaction(async (trx) => {
      await migration.down(trx);
      await trx.query('DELETE FROM migrations WHERE version = ?', [migration.version]);
    });

    console.log(`Migration ${migration.version} rolled back successfully`);
  }

  async runMigrations(migrations: Migration[]): Promise<void> {
    await this.initialize();
    
    const executedMigrations = await this.getExecutedMigrations();
    const pendingMigrations = migrations.filter(m => !executedMigrations.includes(m.version));
    
    console.log(`Found ${pendingMigrations.length} pending migrations`);
    
    for (const migration of pendingMigrations) {
      await this.executeMigration(migration);
    }
  }

  async rollbackMigrations(migrations: Migration[], count: number = 1): Promise<void> {
    await this.initialize();
    
    const executedMigrations = await this.getExecutedMigrations();
    const migrationsToRollback = migrations
      .filter(m => executedMigrations.includes(m.version))
      .sort((a, b) => b.version.localeCompare(a.version))
      .slice(0, count);
    
    console.log(`Rolling back ${migrationsToRollback.length} migrations`);
    
    for (const migration of migrationsToRollback) {
      await this.rollbackMigration(migration);
    }
  }
}

// Initial database setup migration
export const createInitialSchemaMigration = (dbType: DatabaseType): Migration => {
  const schema = getDatabaseSchema(dbType);
  
  return {
    version: '001',
    name: 'create_initial_schema',
    up: async (connection: DatabaseConnection) => {
      // Create tables in order to respect foreign key constraints
      const tableOrder = ['users', 'emergency_contacts', 'rides', 'bookings', 'sos_alerts', 'admins'];
      
      for (const tableName of tableOrder) {
        if (schema[tableName]) {
          await connection.query(schema[tableName]);
        }
      }
    },
    down: async (connection: DatabaseConnection) => {
      // Drop tables in reverse order
      const tableOrder = ['admins', 'sos_alerts', 'bookings', 'rides', 'emergency_contacts', 'users'];
      
      for (const tableName of tableOrder) {
        const dropQuery = dbType === 'oracle' 
          ? `DROP TABLE ${tableName} CASCADE CONSTRAINTS`
          : `DROP TABLE IF EXISTS ${tableName}`;
        
        try {
          await connection.query(dropQuery);
        } catch (error) {
          console.warn(`Failed to drop table ${tableName}:`, error);
        }
      }
    },
  };
};

// Sample data migration
export const createSampleDataMigration = (): Migration => {
  return {
    version: '002',
    name: 'insert_sample_data',
    up: async (connection: DatabaseConnection) => {
      // Insert sample users
      await connection.query(`
        INSERT INTO users (id, email, first_name, last_name, phone, role, is_verified, is_active) VALUES
        ('user-001', 'john.doe@example.com', 'John', 'Doe', '+919876543210', 'user', 1, 1),
        ('driver-001', 'jane.smith@example.com', 'Jane', 'Smith', '+919876543211', 'driver', 1, 1),
        ('admin-001', 'admin@hushryd.com', 'Admin', 'User', '+919876543212', 'admin', 1, 1)
        ON DUPLICATE KEY UPDATE email = VALUES(email)
      `);

      // Insert sample rides
      await connection.query(`
        INSERT INTO rides (id, driver_id, from_latitude, from_longitude, from_address, from_city, from_state, from_country, 
                          to_latitude, to_longitude, to_address, to_city, to_state, to_country, 
                          departure_time, price, currency, max_passengers, available_seats, status,
                          vehicle_make, vehicle_model, vehicle_year, vehicle_color, vehicle_license_plate, vehicle_capacity) VALUES
        ('ride-001', 'driver-001', 17.3850, 78.4867, 'Hyderabad Central', 'Hyderabad', 'Telangana', 'India',
                         13.0827, 80.2707, 'Chennai Central', 'Chennai', 'Tamil Nadu', 'India',
                         DATE_ADD(NOW(), INTERVAL 2 HOUR), 2500.00, 'INR', 4, 3, 'scheduled',
                         'Toyota', 'Innova', 2022, 'White', 'TS09AB1234', 7)
        ON DUPLICATE KEY UPDATE driver_id = VALUES(driver_id)
      `);

      // Insert sample emergency contacts
      await connection.query(`
        INSERT INTO emergency_contacts (id, user_id, name, phone, relationship, is_primary) VALUES
        ('ec-001', 'user-001', 'Emergency Contact 1', '+919876543220', 'Family', 1),
        ('ec-002', 'user-001', 'Emergency Contact 2', '+919876543221', 'Friend', 0)
        ON DUPLICATE KEY UPDATE name = VALUES(name)
      `);
    },
    down: async (connection: DatabaseConnection) => {
      await connection.query('DELETE FROM emergency_contacts WHERE id IN (?, ?)', ['ec-001', 'ec-002']);
      await connection.query('DELETE FROM rides WHERE id = ?', ['ride-001']);
      await connection.query('DELETE FROM users WHERE id IN (?, ?, ?)', ['user-001', 'driver-001', 'admin-001']);
    },
  };
};

// Database initialization function
export const initializeDatabase = async (): Promise<void> => {
  const config = getDatabaseConfig();
  const connection = await dbManager.connect();
  
  try {
    const migrationManager = new MigrationManager(connection, config.type);
    
    // Define all migrations
    const migrations = [
      createInitialSchemaMigration(config.type),
      createSampleDataMigration(),
    ];
    
    // Run migrations
    await migrationManager.runMigrations(migrations);
    
    console.log('Database initialized successfully');
  } catch (error) {
    console.error('Database initialization failed:', error);
    throw error;
  } finally {
    await dbManager.disconnect();
  }
};

// Database health check
export const checkDatabaseHealth = async (): Promise<boolean> => {
  try {
    const connection = await dbManager.connect();
    await connection.query('SELECT 1');
    await dbManager.disconnect();
    return true;
  } catch (error) {
    console.error('Database health check failed:', error);
    return false;
  }
};
